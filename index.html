<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数字锁相放大器仿真 (BPSK Edition)</title>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { background-color: #0f172a; color: white; margin: 0; overflow: hidden; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        .bit-cell { font-family: 'Courier New', monospace; width: 1.5ch; display: inline-block; text-align: center; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Icons ---
        const IconActivity = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>;
        const IconZap = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>;
        const IconNoise = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 12h10"/><path d="M10 9v6"/><path d="M14 9v6"/></svg>;
        const IconSettings = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const IconSliders = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="4" x2="4" y1="21" y2="14"/><line x1="4" x2="4" y1="10" y2="3"/><line x1="12" x2="12" y1="21" y2="12"/><line x1="12" x2="12" y1="8" y2="3"/><line x1="20" x2="20" y1="21" y2="16"/><line x1="20" x2="20" y1="12" y2="3"/><line x1="2" x2="6" y1="14" y2="14"/><line x1="10" x2="14" y1="8" y2="8"/><line x1="18" x2="22" y1="16" y2="16"/></svg>;
        const IconRadio = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4.9 19.1C1 15.2 1 8.8 4.9 4.9"/><path d="M7.8 16.2c-2.3-2.3-2.3-6.1 0-8.5"/><circle cx="12" cy="12" r="2"/><path d="M16.2 7.8c2.3 2.3 2.3 6.1 0 8.5"/><path d="M19.1 4.9C23 8.8 23 15.2 19.1 19.1"/></svg>;

        // --- Logic Constants ---
        const MAX_VOLTAGE = 5.0;
        const BIT_RATE = 4; // 4 bits per second
        const BIT_DURATION = 1.0 / BIT_RATE;

        // --- Helpers ---
        const generateGaussianNoise = (mean, stdDev) => {
          let u = 0, v = 0;
          while(u === 0) u = Math.random(); 
          while(v === 0) v = Math.random();
          return mean + stdDev * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        };

        const lowPassFilter = (currentInput, prevOutput, alpha) => {
          return alpha * currentInput + (1 - alpha) * prevOutput;
        };

        // --- Components ---
        const ControlSlider = ({ label, value, min, max, step, onChange, unit, logScale = false }) => {
          const displayValue = logScale ? Math.pow(10, value).toExponential(1) : value;
          return (
            <div className="mb-4">
              <div className="flex justify-between items-center mb-1">
                <label className="text-xs font-medium text-slate-300">{label}</label>
                <span className="text-xs font-mono text-cyan-400">{logScale ? displayValue : value} {unit}</span>
              </div>
              <input type="range" min={min} max={max} step={step} value={value} onChange={(e) => onChange(parseFloat(e.target.value))} className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500 hover:accent-cyan-400"/>
            </div>
          );
        };

        const ToggleSwitch = ({ label, checked, onChange }) => (
          <div className="flex justify-between items-center mb-4">
            <label className="text-xs font-medium text-slate-300">{label}</label>
            <button onClick={() => onChange(!checked)} className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none ${checked ? 'bg-cyan-600' : 'bg-slate-700'}`}>
              <span className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${checked ? 'translate-x-6' : 'translate-x-1'}`}/>
            </button>
          </div>
        );

        const BitDisplay = ({ title, bits, currentIndex, isRx = false }) => {
          return (
            <div className="bg-slate-950 p-2 rounded border border-slate-700 font-mono text-xs overflow-hidden">
              <div className="flex justify-between items-center mb-1">
                <span className="text-slate-400">{title}</span>
                {isRx && <span className="text-cyan-400">Rate: {BIT_RATE} bps</span>}
              </div>
              <div className="break-all tracking-widest leading-loose">
                {bits.split('').map((bit, idx) => {
                    const isActive = idx === currentIndex;
                    // For Rx, we only color if we have actually received it (idx <= currentIndex)
                    // But for the "cursor", we just highlight current.
                    // Let's highlight the current cursor.
                    
                    let colorClass = "text-slate-500";
                    if (isActive) {
                        colorClass = isRx ? "text-green-400 bg-green-900/50 font-bold border-b-2 border-green-500" : "text-cyan-400 bg-cyan-900/50 font-bold border-b-2 border-cyan-500";
                    } else if (isRx && idx < currentIndex) {
                         // Past received bits
                         colorClass = "text-green-600"; 
                    }
                    
                    return <span key={idx} className={`inline-block px-1 rounded mx-[1px] ${colorClass}`}>{bit}</span>
                })}
              </div>
            </div>
          );
        };

        const LockInAmplifier = () => {
          // Simulation Params
          const [signalFreq, setSignalFreq] = useState(25000);
          const [signalAmp, setSignalAmp] = useState(0.1);
          const [noiseEnabled, setNoiseEnabled] = useState(true);
          const [noisePower, setNoisePower] = useState(0.05);
          const [dliaEnabled, setDliaEnabled] = useState(true);
          const [timeConstantLog, setTimeConstantLog] = useState(-3);
          const [inputScale, setInputScale] = useState(10.0);
          const [outputScale, setOutputScale] = useState(10.0);
          const [isPaused, setIsPaused] = useState(false);
          
          // BPSK Params
          const [bpskEnabled, setBpskEnabled] = useState(false);
          const [bitSequence, setBitSequence] = useState("11010010111000101010111100001101");
          const [rxBits, setRxBits] = useState("0".repeat(32));
          const [currentTxIndex, setCurrentTxIndex] = useState(0);

          const canvasTopRef = useRef(null);
          const canvasBottomRef = useRef(null);
          const animationRef = useRef(null);
          const readoutRef = useRef(null);
          
          // Refs for mutable simulation state
          const simState = useRef({ 
            displayTime: 0,   // Fast running time for oscilloscope scrolling
            globalTime: 0,    // Real-world running time for bit synchronization
            lastFrameTime: 0, // Performance.now() timestamp
            lpfX: 0, 
            lpfY: 0,
            sampledBitIndex: -1 // Tracks which bit index was last sampled
          });

          // Reset Logic
          const resetSimulation = () => {
             simState.current.globalTime = 0;
             simState.current.sampledBitIndex = -1;
             simState.current.lpfX = 0;
             simState.current.lpfY = 0;
             setRxBits("0".repeat(bitSequence.length));
             setCurrentTxIndex(0);
          };

          // Handle input change for bit sequence
          const handleBitSequenceChange = (e) => {
            const val = e.target.value.replace(/[^01]/g, '').slice(0, 32);
            setBitSequence(val);
            // Don't full reset, just clear RX to indicate change
            setRxBits("0".repeat(val.length));
          };

          // Reset when enabling BPSK
          useEffect(() => {
              if (bpskEnabled) {
                  resetSimulation();
              }
          }, [bpskEnabled, bitSequence]); // Reset if seq changes or toggle

          const draw = useCallback(() => {
            const canvasTop = canvasTopRef.current;
            const canvasBottom = canvasBottomRef.current;
            if (!canvasTop || !canvasBottom) return;

            const ctxTop = canvasTop.getContext('2d');
            const ctxBottom = canvasBottom.getContext('2d');
            const width = canvasTop.width;
            const height = canvasTop.height;

            // --- Time Management ---
            const now = performance.now();
            let dt = (now - simState.current.lastFrameTime) / 1000;
            simState.current.lastFrameTime = now;
            
            // Limit dt to avoid huge jumps if tab was inactive
            if (dt > 0.1) dt = 0.1;
            if (isPaused) dt = 0;

            // Update Global Time (Real world seconds)
            simState.current.globalTime += dt;
            
            // --- Canvas Setup ---
            ctxTop.fillStyle = '#0f172a';
            ctxBottom.fillStyle = '#0f172a';
            ctxTop.fillRect(0, 0, width, height);
            ctxBottom.fillRect(0, 0, width, height);

            const drawGrid = (ctx) => {
              ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1; ctx.beginPath();
              for (let x = 0; x < width; x += 50) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
              for (let y = 0; y < height; y += 50) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
              ctx.stroke();
              ctx.strokeStyle = '#334155'; ctx.beginPath(); ctx.moveTo(0, height / 2); ctx.lineTo(width, height / 2); ctx.stroke();
            };
            drawGrid(ctxTop); drawGrid(ctxBottom);

            // --- Physics Update (LPF Dynamics) ---
            // We update the LPF state based on the "macro" bit state first
            // to ensure the voltage level is correct for the current time.
            
            const totalBits = bitSequence.length || 1;
            // Calculate which bit we are currently transmitting
            const rawBitIndex = Math.floor(simState.current.globalTime * BIT_RATE);
            const currentBitIdx = rawBitIndex % totalBits;
            const currentBitChar = bitSequence[currentBitIdx] || '0';
            const currentBitVal = (bpskEnabled && currentBitChar === '0') ? -1 : 1;

            // Theoretical Target for LIA LPF (X component)
            // Signal = Amp * Bit * sin(wt) + Noise
            // Ref = sin(wt)
            // Mixer = Signal * Ref = Amp * Bit * sin^2(wt) = Amp * Bit * 0.5 * (1 - cos(2wt))
            // LPF removes 2wt term -> Target = Amp * Bit * 0.5
            const lpfTargetX = signalAmp * currentBitVal * 0.5;

            // Apply exponential decay to simulate filter settling
            // Alpha for discrete update: 1 - exp(-dt / tau)
            const timeConstant = Math.pow(10, timeConstantLog);
            const smoothingFactor = 1 - Math.exp(-dt / timeConstant);
            
            if (dliaEnabled) {
                simState.current.lpfX += (lpfTargetX - simState.current.lpfX) * smoothingFactor;
            } else {
                simState.current.lpfX = 0;
            }

            // --- Sampling Logic ---
            // Sample exactly once per bit, at the middle (offset + 0.5)
            // We use rawBitIndex to track unique bit slots
            if (bpskEnabled && dliaEnabled) {
                // Check if we are past the 50% mark of the current bit
                const bitProgress = (simState.current.globalTime * BIT_RATE) % 1.0;
                
                if (bitProgress > 0.5 && simState.current.sampledBitIndex < rawBitIndex) {
                    // Trigger Sample
                    simState.current.sampledBitIndex = rawBitIndex;
                    const detectedVal = simState.current.lpfX > 0 ? '1' : '0';
                    
                    // Update Rx Buffer via Ref to avoid react loop in animation
                    if (readoutRef.current) {
                        readoutRef.current.dataset.rxBitIndex = currentBitIdx;
                        readoutRef.current.dataset.rxBitVal = detectedVal;
                        readoutRef.current.dataset.syncTrigger = rawBitIndex; // trigger attribute
                    }
                }
            }

            // --- Oscilloscope Visualization ---
            // We draw a fast-moving window "snapshot"
            const timeWindow = 0.0005; 
            const timeStepPerPixel = timeWindow / width;
            
            // Advance the "Display Time" for the scrolling sine wave effect
            if (!isPaused) {
                simState.current.displayTime += timeStepPerPixel * 5; 
            }

            ctxTop.beginPath(); ctxBottom.beginPath();
            ctxTop.strokeStyle = '#22d3ee'; 
            ctxBottom.strokeStyle = bpskEnabled ? '#a3e635' : '#facc15';
            ctxTop.lineWidth = 2; ctxBottom.lineWidth = 2;

            for (let x = 0; x < width; x++) {
              // t_wave is for the high-freq carrier visualization
              const t_wave = simState.current.displayTime + x * timeStepPerPixel;
              
              const pureSignal = signalAmp * currentBitVal * Math.sin(2 * Math.PI * signalFreq * t_wave);
              const noise = noiseEnabled ? generateGaussianNoise(0, noisePower) : 0;
              let analogInput = pureSignal + noise;
              
              // Clip
              if (analogInput > MAX_VOLTAGE) analogInput = MAX_VOLTAGE;
              if (analogInput < -MAX_VOLTAGE) analogInput = -MAX_VOLTAGE;

              // For Output trace:
              // We use the physically calculated lpfX as the DC baseline
              // And add some small ripple to make it look "live" (optional)
              // Or simply draw the current LPF state (flat line that moves up/down)
              let plotValue = 0;
              
              if (dliaEnabled) {
                  if (bpskEnabled) {
                      // Show X component * 2 (to recover amplitude scale)
                      // Add a tiny bit of noise/ripple proportional to noise to look realistic
                      const ripple = noise * 0.1; 
                      plotValue = (simState.current.lpfX * 2) + ripple;
                  } else {
                      // Magnitude mode (traditional)
                      // Just approximate for visual since we aren't running full quadrature sim per pixel
                      // Recalculate basic magnitude based on current state
                      const lpfY_Target = 0; // In-phase signal has 0 Y component mean
                      // simState.current.lpfY ... (omitted for simplicity in this hybrid mode)
                      const mag = 2 * Math.sqrt(simState.current.lpfX * simState.current.lpfX); 
                      plotValue = mag + (noise * 0.05);
                  }
              }

              // Plot Top
              const plotYTop = (height / 2) - (analogInput * inputScale) * (height / 2.5) / 5;
              if (x === 0) ctxTop.moveTo(x, plotYTop); else ctxTop.lineTo(x, plotYTop);

              // Plot Bottom
              const plotYBottom = (height / 2) + (height / 4) - (plotValue * outputScale) * (height / 2.5) / 5; 
              if (x === 0) ctxBottom.moveTo(x, plotYBottom); else ctxBottom.lineTo(x, plotYBottom);
            }

            ctxTop.stroke(); ctxBottom.stroke();

            // --- UI Updates ---
            if (readoutRef.current) {
                // Voltage text
                const voltageVal = bpskEnabled ? (simState.current.lpfX * 2) : 0;
                readoutRef.current.innerText = dliaEnabled ? voltageVal.toFixed(4) : '0.0000';
                
                // Rx Sync Update
                // We check if the dataset has a new trigger
                if (bpskEnabled && readoutRef.current.dataset.syncTrigger) {
                    const triggerId = parseInt(readoutRef.current.dataset.syncTrigger);
                    // Use a simple global variable check or React state ref check to see if we processed this
                    if (triggerId !== readoutRef.current._lastProcessedTrigger) {
                        readoutRef.current._lastProcessedTrigger = triggerId;
                        
                        const idx = parseInt(readoutRef.current.dataset.rxBitIndex);
                        const val = readoutRef.current.dataset.rxBitVal;
                        
                        // Force update React state
                        setCurrentTxIndex(idx);
                        setRxBits(prev => {
                            const arr = prev.split('');
                            arr[idx] = val;
                            return arr.join('');
                        });
                    }
                } else if (!bpskEnabled) {
                    // Update tx index just for visual continuity if needed, or reset
                }
            }

            animationRef.current = requestAnimationFrame(draw);
          }, [signalFreq, signalAmp, noiseEnabled, noisePower, dliaEnabled, timeConstantLog, inputScale, outputScale, isPaused, bpskEnabled, bitSequence]);

          useEffect(() => {
            animationRef.current = requestAnimationFrame(draw);
            return () => cancelAnimationFrame(animationRef.current);
          }, [draw]);

          return (
            <div className="flex flex-col md:flex-row h-screen font-sans overflow-hidden">
              {/* Left Panel */}
              <div className="w-full md:w-80 bg-slate-900 border-r border-slate-800 flex flex-col h-full overflow-y-auto custom-scrollbar shadow-2xl z-20">
                <div className="p-5 border-b border-slate-800 bg-slate-900 sticky top-0 z-10">
                  <h1 className="text-xl font-bold flex items-center gap-2 text-cyan-400"><IconActivity /> DLIA Sim</h1>
                  <p className="text-xs text-slate-500 mt-1">Digital Lock-In Amplifier</p>
                </div>
                <div className="p-5 space-y-8 pb-20">
                  
                  {/* Signal Source */}
                  <section>
                    <h2 className="text-sm font-semibold text-white flex items-center gap-2 mb-4"><IconZap /> 信号源设置</h2>
                    <ControlSlider label="载波频率" value={signalFreq} min={5000} max={60000} step={100} unit="Hz" onChange={setSignalFreq} />
                    <ControlSlider label="信号幅值" value={signalAmp} min={0.01} max={1.0} step={0.01} unit="V" onChange={setSignalAmp} />
                  </section>

                  {/* BPSK Control */}
                  <section className="border-t border-slate-800 pt-6">
                    <h2 className="text-sm font-semibold text-white flex items-center gap-2 mb-4"><IconRadio /> 通信调制 (BPSK)</h2>
                    <ToggleSwitch label="启用 BPSK 调制" checked={bpskEnabled} onChange={setBpskEnabled} />
                    
                    {bpskEnabled && (
                        <div className="space-y-3">
                            <div>
                                <label className="text-xs font-medium text-slate-300 block mb-1">32-bit 发送序列 (0/1)</label>
                                <textarea 
                                    className="w-full bg-slate-950 border border-slate-700 rounded p-2 text-xs font-mono text-cyan-400 focus:outline-none focus:border-cyan-500 resize-none"
                                    rows="3"
                                    value={bitSequence}
                                    onChange={handleBitSequenceChange}
                                    maxLength={32}
                                />
                                <div className="text-[10px] text-slate-500 text-right">{bitSequence.length}/32 bits</div>
                            </div>
                            <div className="text-xs text-slate-400 bg-slate-800/50 p-2 rounded">
                                <p>速率: {BIT_RATE} bps</p>
                                <p>映射: 1→0°, 0→180°</p>
                            </div>
                        </div>
                    )}
                  </section>

                  {/* Noise Control */}
                  <section className="border-t border-slate-800 pt-6">
                    <h2 className="text-sm font-semibold text-white flex items-center gap-2 mb-4"><IconNoise /> 信道噪声</h2>
                    <ToggleSwitch label="叠加高斯白噪声" checked={noiseEnabled} onChange={setNoiseEnabled} />
                    <ControlSlider label="噪声功率" value={noisePower} min={0} max={2.0} step={0.01} unit="Vrms" onChange={setNoisePower} />
                  </section>

                  {/* LIA Control */}
                  <section className="border-t border-slate-800 pt-6">
                    <h2 className="text-sm font-semibold text-white flex items-center gap-2 mb-4"><IconSettings /> 解调与滤波</h2>
                    <ToggleSwitch label="启用锁相处理" checked={dliaEnabled} onChange={setDliaEnabled} />
                    <ControlSlider label="积分时间常数" value={timeConstantLog} min={-5} max={-1} step={0.1} unit="s" logScale={true} onChange={setTimeConstantLog} />
                  </section>

                  <section className="border-t border-slate-800 pt-6">
                     <button onClick={() => setIsPaused(!isPaused)} className={`w-full py-2 rounded-lg font-medium transition-all ${isPaused ? 'bg-green-600 hover:bg-green-500' : 'bg-red-600 hover:bg-red-500'}`}>
                       {isPaused ? '继续仿真' : '暂停显示'}
                     </button>
                  </section>
                </div>
              </div>

              {/* Right Panel */}
              <div className="flex-1 flex flex-col h-full bg-slate-950 p-4 gap-4 relative">
                
                {/* BPSK Dashboard overlay */}
                {bpskEnabled && (
                    <div className="bg-slate-900 border border-slate-800 rounded-xl p-3 flex flex-col gap-2 shadow-lg">
                        <div className="flex justify-between items-center border-b border-slate-800 pb-2 mb-1">
                             <h3 className="text-sm font-bold text-white flex items-center gap-2"><IconRadio /> 实时数字解调监控</h3>
                             <span className="text-xs text-slate-500">Sync: Locked ({BIT_RATE}Hz)</span>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                             <BitDisplay title="Tx 发送队列 (Input)" bits={bitSequence} currentIndex={currentTxIndex} />
                             <BitDisplay title="Rx 解调结果 (Output)" bits={rxBits} currentIndex={currentTxIndex} isRx={true} />
                        </div>
                    </div>
                )}

                {/* Oscilloscopes */}
                <div className="flex-1 bg-slate-900 rounded-xl border border-slate-800 relative flex flex-col overflow-hidden shadow-lg group">
                  <div className="absolute top-3 left-4 z-10 bg-slate-950/80 backdrop-blur px-3 py-1 rounded border border-slate-700 shadow-sm">
                    <h3 className="text-xs font-bold text-cyan-400">ADC Input Signal (Time Domain)</h3>
                  </div>
                  <div className="absolute top-3 right-4 z-10 w-48 flex items-center gap-2 bg-slate-950/80 backdrop-blur p-2 rounded border border-slate-700 opacity-30 group-hover:opacity-100 transition-opacity">
                      <IconSliders />
                      <input type="range" min="1" max="50" step="1" value={inputScale} onChange={(e) => setInputScale(parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" />
                  </div>
                  <canvas ref={canvasTopRef} width={1000} height={400} className="w-full h-full object-cover" />
                </div>

                <div className="flex-1 bg-slate-900 rounded-xl border border-slate-800 relative flex flex-col overflow-hidden shadow-lg group">
                  <div className="absolute top-3 left-4 z-10 bg-slate-950/80 backdrop-blur px-3 py-1 rounded border border-slate-700 shadow-sm">
                    <h3 className={`text-xs font-bold ${bpskEnabled ? 'text-lime-400' : 'text-yellow-400'}`}>
                        {bpskEnabled ? "Demodulated X-Component (In-Phase)" : "LIA Magnitude Output"}
                    </h3>
                  </div>
                  <div className="absolute top-3 right-4 z-10 w-48 flex items-center gap-2 bg-slate-950/80 backdrop-blur p-2 rounded border border-slate-700 opacity-30 group-hover:opacity-100 transition-opacity">
                      <IconSliders />
                      <input type="range" min="1" max="50" step="1" value={outputScale} onChange={(e) => setOutputScale(parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer" />
                  </div>
                  <canvas ref={canvasBottomRef} width={1000} height={400} className="w-full h-full object-cover" />
                   
                   {/* Voltage Readout */}
                   <div className="absolute bottom-2 right-4 bg-slate-950/50 backdrop-blur px-3 py-1 rounded-lg border border-slate-800/50 flex flex-col items-end">
                     <div className={`text-2xl font-mono font-bold drop-shadow-lg flex items-center gap-2 ${bpskEnabled ? 'text-lime-400' : 'text-yellow-500'}`}>
                       <span ref={readoutRef}>0.0000</span> V
                     </div>
                     <div className="text-[10px] text-slate-400 font-mono">Instantaneous Value</div>
                   </div>
                </div>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<LockInAmplifier />);
    </script>
</body>
</html>